## 1. JAVA 概述

## 2. 基本语法

## 3. 数组

## 4. 面向的对象 - 上

## 5.  面向对象 - 中

### 5.1 面向对象的特征二：继承性

#### 1.  为什么要有类的继承性？(继承性的好处）

 1.  减少了代码的冗余，提高了代码的复用性

 2.  便于功能的扩展

 3.  为之后多态性的使用，提供了前提

  ![image-20210215102944542](C:\Users\10137\AppData\Roaming\Typora\typora-user-images\image-20210215102944542.png)



#### 2. 继承性的格式：

class A extends B{}


 A:子类、派生类、subclass
 
 B:父类、超类、基类、superclass



#### 3. 子类继承父类以后有哪些不同？

#####3.1 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。

   特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。

#####3.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。
     
 子类和父类的关系，不同于子集和集合的关系。
 extends：延展、扩展



#### 4. Java中继承性的说明

1. 一个类可以被多个子类继承。
2.  Java中类的单继承性：一个类只能有一个父类
3. 子父类是相对的概念。
4. 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类
5. 子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法

![image-20210215103211173](C:\Users\10137\AppData\Roaming\Typora\typora-user-images\image-20210215103211173.png)

#### 5. java.lang.Object类的理解

1. 如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类
2. 所的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类
3. 意味着，所的java类具有java.lang.Object类声明的功能。





### 5.2 方法的重写

#### 1. 什么是方法的重写(override 或 overwrite)？

子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作

#### 2. 应用

重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法

#### 3. 举例

#### 4. 重写的规则

方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
 								 //方法体

约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法

1.子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同

2.子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符

特殊情况：子类不能重写父类中声明为private权限的方法

3.返回值类型：

3.1 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
	
3.2 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
	
3.3 父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)

4.子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）

注：子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。	



#### 5. 面试题
区分方法的重写和重载？
答： ① 二者的概念：
         ② 重载和重写的具体规则
         ③ 重载：不表现为多态性

重写：表现为多态性。
重载：是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。

所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“**早绑定**”或“**静态绑定**”；

而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“**晚绑定**”或“**动态绑定**”。 

引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”





### 5.3 super

#### 1. super 关键字可以理解为：父类的

#### 2.可以用来调用的结构：

属性、方法、构造器

#### 3. super调用属性、方法：

3.1 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。
3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。

#### 4. super调用构造器：

4.1  我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
4.2 "super(形参列表)"的使用，必须声明在子类构造器的首行！
4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二一，不能同时出现
4.4 在构造器的首行，没显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()
4.5 在类的多个构造器中，至少一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器



### 5.3 子类对象实例化全过程

#### 1.从结果上看：继承性

子类继承父类以后，就获取了父类中声明的属性或方法。
创建子类的对象，在堆空间中，就会加载所父类中声明的属性。

#### 2.从过程上看：

当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。

![image-20210215171734068](C:\Users\10137\AppData\Roaming\Typora\typora-user-images\image-20210215171734068.png)

#### 3.强调说明：

虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。

<img src="C:\Users\10137\AppData\Roaming\Typora\typora-user-images\image-20210215172059526.png" alt="image-20210215172059526" style="zoom: 67%;" />

### 5.4 多态

#### 1.多态性的理解：可以理解为一个事物的多种形态。

#### 2.何为多态性：

对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）
举例：
Person p = new Man();
Object obj = new Date();

#### 3.多态性的使用：虚拟方法调用

有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
总结：编译，看左边；运行，看右边。

#### 4.多态性的使用前提：

① 类的继承关系  ② 方法的重写

#### 5.多态性的应用举例：

举例一：
public void func(Animal animal){//Animal animal = new Dog();
	animal.eat();
	animal.shout();
}
举例二：
public void method(Object obj){

}

举例三：
class Driver{

public void doData(Connection conn){//conn = new MySQlConnection(); / conn = new OracleConnection();
		//规范的步骤去操作数据
//		conn.method1();
//		conn.method2();
//		conn.method3();
			}

}

#### 6.多态性使用的注意点：

对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

#### 7.关于向上转型与向下转型：

#### 7.1 向上转型：多态

#### 7.2 向下转型：

#### 7.2.1 为什么使用向下转型：

有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。

#### 7.2.2 如何实现向下转型：

使用强制类型转换符：()

#### 7.2.3 使用时的注意点：

① 使用强转时，可能出现ClassCastException的异常。
② 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。

#### 7.2.4 instanceof的使用：

① a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。
② 如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。
③ 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。

#### 7.2.5 图示：

![image-20210217130104175](C:\Users\10137\AppData\Roaming\Typora\typora-user-images\image-20210217130104175.png)

#### 8. 面试题：

8.1 谈谈你对多态性的理解？
① 实现代码的通用性。
② Object类中定义的public boolean equals(Object obj){  }
 JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)
③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）
8.2 多态是编译时行为还是运行时行为？





### 5.5 Object类的使用

#### 1.java.lang.Object类的说明：

1.Object类是所Java类的根父类
2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为 java.lang.Object类 
3.Object类中的功能(属性、方法)就具通用性。
	 属性：无
 	方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()
 wait() 、 notify()、notifyAll()

4.Object类只声明了一个空参的构造器

##### 2.equals()方法
#### 2.1 equals()的使用：
1.是一个方法，而非运算符
2.只能适用于引用数据类型
3.Object类中equals()的定义：
 public boolean equals(Object obj) {
           return (this == obj);
     }
说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体

4.像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。 

5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们就需要对Object类中的equals()进行重写.
重写的原则：比较两个对象的实体内容是否相同.

#### 2.2 如何重写equals()

#### 2.2.1 手动重写举例：

class User{
String name;
int age;
//重写其equals()方法
public boolean equals(Object obj){
	if(obj == this){
		return true;
	}
	if(obj instanceof User){
		User u = (User)obj;
		return this.age == u.age && this.name.equals(u.name);
	}
	return false;
}
}

#### 2.2.2 开发中如何实现：自动生成的

#### 3. 回顾 == 运算符的使用：

== ：运算符

 * 可以使用在基本数据类型变量和引用数据类型变量中
 * 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）

如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体

补充： == 符号使用时，必须保证符号左右两边的变量类型一致。

toString()方法

#### 3.1 toString()的使用：

当我们输出一个对象的引用时，实际上就是调用当前对象的toString()



Object类中toString()的定义：

public String toString() {
   return getClass().getName() + "@" + Integer.toHexString(hashCode());
}



像String、Date、File、包装类等都重写了Object类中的toString()方法。

使得在调用对象的toString()时，返回"实体内容"信息



自定义类也可以重写toString()方法，当调用此方法时，返回对象的"实体内容"

#### 3.2 如何重写toString()

举例：
//自动实现

	@Override
	public String toString() {
		return "Customer [name=" + name + ", age=" + age + "]";
	}

#### 4.面试题：

① final、finally、finalize的区别？
②  == 和 equals() 区别



### 5.6 单元测试

Java中的JUnit单元测试



步骤：

1.中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步

2.创建Java类，进行单元测试。

此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器

3.此类中声明单元测试方法。

此时的单元测试方法：方法的权限是public,没返回值，没形参



4.此单元测试方法上需要声明注解：@Test01,并在单元测试类中导入：import org.junit.Test01;



5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。

6.写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test01



说明：

1.如果执行结果没任何异常：绿条

2.如果执行结果出现异常：红条



### 5.7 包装类

#### 1.为什么要有包装类(或封装类）

为了使基本数据类型的变量具有类的特征，引入包装类。

#### 2.基本数据类型与对应的包装类：

![image-20210217135004689](C:\Users\10137\AppData\Roaming\Typora\typora-user-images\image-20210217135004689.png)

#### 3.需要掌握的类型间的转换：（基本数据类型、包装类、String）

![image-20210217135010336](C:\Users\10137\AppData\Roaming\Typora\typora-user-images\image-20210217135010336.png)

###### 简易版：

基本数据类型<--->包装类：JDK 5.0 新特性：自动装箱 与自动拆箱
基本数据类型、包装类--->String:调用String重载的valueOf(Xxx xxx)
String--->基本数据类型、包装类:调用包装类的parseXxx(String s)
     注意：转换时，可能会报NumberFormatException
应用场景举例：
① Vector类中关于添加元素，只定义了形参为Object类型的方法：
v.addElement(Object obj);   //基本数据类型 --->包装类 --->使用多态

###### 



## 6. 面向对象 - 下

### 6.1 关键字 static

#### static:静态的

#### 1.可以用来修饰的结构：主要用来修饰类的内部结构

属性、方法、代码块、内部类

#### 2.static修饰属性：静态变量（或类变量）

##### 2.1 属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)

实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。

静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。

##### 2.2 static修饰属性的其他说明：

① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用

② 静态变量的加载要早于对象的创建。

③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。

④		类变量	实例变量

类		yes		no

对象	yes		yes

​	

##### 2.3 静态属性举例：System.out; Math.PI;

#### 3.静态变量内存解析：

![image-20210219122455809](C:\Users\10137\AppData\Roaming\Typora\typora-user-images\image-20210219122455809.png)

#### 4.static修饰方法：静态方法、类方法

① 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用
②			          静态方法	非静态方法

​	类		    yes		no

​	对象		yes		yes
③ 静态方法中，只能调用静态的方法或属性
  非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性

##### static的注意点：

##### 5.1 在静态的方法内，不能使用this关键字、super关键字

##### 5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。

#### 6.如何判定属性和方法应该使用static关键字：

##### 6.1 关于属性

属性是可以被多个对象所共享的，不会随着对象的不同而不同的。
类中的常量也常常声明为static

##### 6.2 关于方法

操作静态属性的方法，通常设置为static的
工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections

#### 7.使用举例：

举例一：Arrays、Math、Collections等工具类
举例二：单例模式
举例三：

````
class Circle{

	private double radius;
	private int id;//自动赋值
	
	public Circle(){
	id = init++;
	total++;
	}
	
	public Circle(double radius){
	this();
		id = init++;
		total++;
		this.radius = radius;
		

	}
	
	private static int total;//记录创建的圆的个数
	private static int init = 1001;//static声明的属性被所对象所共享
	
	public double findArea(){
		return 3.14 * radius * radius;
	}
	
	public double getRadius() {
		return radius;
	}
	
	public void setRadius(double radius) {
		this.radius = radius;
	}
	
	public int getId() {
		return id;
	}
	
	public static int getTotal() {
		return total;
	}
}
````



### 6.1.1 单例模式

#### 1.设计模式的说明

##### 1.1 理解

设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。

##### 1.2 常用设计模式  --- 23种经典的设计模式  GOF

创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 
结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 
行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 

#### 2.单例模式

##### 2.1 要解决的问题：

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。

##### 2.2 具体代码的实现：

饿汉式1：
````
class Bank{
	
	//1.私化类的构造器
	private Bank(){
		
	}
	
	//2.内部创建类的对象
	//4.要求此对象也必须声明为静态的
	private static Bank instance = new Bank();
	
	//3.提供公共的静态的方法，返回类的对象
	public static Bank getInstance(){
		return instance;
	}
}
````
饿汉式2：使用了静态代码块
````
class Order{
	
	//1.私化类的构造器
	private Order(){
		
	}
	
	//2.声明当前类对象，没初始化
	//4.此对象也必须声明为static的
	private static Order instance = null;
	
	static{
		instance = new Order();
 }
	
	//3.声明public、static的返回当前类对象的方法
	public static Order getInstance(){
		return instance;
	}

}
````
懒汉式：
````
class Order{
	
	//1.私化类的构造器
	private Order(){
		
	}
	
	//2.声明当前类对象，没初始化
	//4.此对象也必须声明为static的
	private static Order instance = null;
	
	//3.声明public、static的返回当前类对象的方法
	public static Order getInstance(){
		
		if(instance == null){
			
			instance = new Order();
			
		}
		return instance;
	}
}
````

##### 2.3 两种方式的对比：

饿汉式：	

坏处：对象加载时间过长。

好处：饿汉式是线程安全的



懒汉式：好处：延迟对象的创建。

目前的写法坏处：线程不安全。--->到多线程内容时，再修改



### 6.2 main 

main()方法作为程序的入口

main()方法也是一个普通的静态方法

main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）

如何将控制台获取的数据传给形参：String[] args?
  运行时：java 类名 "Tom" "Jerry" "123" "true"

sysout(args[0]);//"Tom"
sysout(args[3]);//"true"  -->Boolean.parseBoolean(args[3]);
sysout(args[4]);//报异常

小结：一叶知秋
public static void main(String[] args){//方法体}

权限修饰符：private 缺省 protected pubilc ---->封装性
修饰符：static \ final \ abstract \native 可以用来修饰方法
返回值类型： 无返回值 / 有返回值 -->return
方法名：需要满足标识符命名的规则、规范；"见名知意"
形参列表：重载 vs 重写；参数的值传递机制；体现对象的多态性
方法体：来体现方法的功能

````
main(){
Person p = new Man();
p.eat();
//p.earnMoney();

Man man = new Man();
man.eat();
man.earnMoney();
}
````




### 6.3 类的结构之四代码块

类的成员之四：代码块(初始化块)（重要性较属性、方法、构造器差一些）

#### 1.代码块的作用：用来初始化类、对象的信息

#### 2.分类：代码块要是使用修饰符，只能使用static

分类：静态代码块  vs 非静态代码块

#### 3.静态代码块：

内部可以输出语句
随着类的加载而执行,而且只执行一次
作用：初始化类的信息
如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
静态代码块的执行要优先于非静态代码块的执行
静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构

非静态代码块：

内部可以输出语句
随着对象的创建而执行
每创建一个对象，就执行一次非静态代码块
作用：可以在创建对象时，对对象的属性等进行初始化
如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行
非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法



#### 4.实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：

对应的练习：LeafTest.java / Son.java
由父及子，静态先行。

### 6.3.1  执行顺序

①默认初始化

②显式初始化/⑤在代码块中赋值

③构造器中初始化

④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值



执行的先后顺序：① - ② / ⑤ - ③ - ④





### 7. final：最终的

#### 1.可以用来修饰：类、方法、变量

#### 2.具体的：

##### 2.1 final 用来修饰一个类:此类不能被其他类所继承。

比如：String类、System类、StringBuffer类

##### 2.2 final 用来修饰方法：表明此方法不可以被重写

比如：Object类中getClass();

##### 2.3 final 用来修饰变量：此时的"变量"就称为是一个常量

final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化

final修饰局部变量：

尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。



static final 用来修饰属性：全局常量